# Implement the Simulated Annealing Algorithm

The idea behind this workshop is not to teach you how to implement the simulated annealing algorithm, but to show you how you can start to use Rust.
Therefore we will use Shamit's R implementation and convert that to Rust.

## scaling of the data

This is the scale.01 function in R:
```
scale.01 <- function(v){
  sc.01 <- (v-min(v))/(max(v)-min(v))
  sc.01
}
```

In Rust I would like not exactly this functionality, but a function that converts our data object in place:

```
    pub fn scale_01( &mut self){
            for row in &mut self.data {
                let mut min = f32::INFINITY;
                let mut max = f32::NEG_INFINITY;
                for i in 0..row.len(){
                    min = min.min(row[i]);
                    max = max.max(row[i]);
                    
                }
                // Now apply the scaling using the min/max in place
                for entry in row {
                    *entry = (*entry - min) / (max - min);  // In-place scaling
                }
            }
    }
```

## Calculating Cluster Energy

The R function uses a lot of R specific niceties like 'which' and 'dist' which we unfortunately need to implement in Rust.


```
# This function calculates the energy of a single cluster only (coi- cluster of interest)
calc.Ek <- function(m,clus,coi){

  clus.d <- m[which(clus==coi),]
  Ek <- sum(dist(clus.d))
  Ek
}
```
But that is not complicated:

```
    /// Function to compute the Euclidean distance between rows of data
    fn euclidean_distance(&self, i: usize, j: usize ) -> f32 {
        let v1 = &self.data[i];
        let v2 = &self.data[j];
        let mut sum:f32 = 0.0;
        for i in 0..v1.len(){
            sum += (v1[i] - v2[i]).powi(2);
        }
        sum.sqrt()
    }
    
    /// Calculates the cluster energy
    fn calc_ek(&self, clus: usize) -> f32 {
        let ids = self.cluster_rows( clus );
        //println!("I found these cluster gene ids: {:?}",ids);
        let mut sum = 0.0;
        for i in 0..ids.len() {
            for j in i+1..ids.len() {
                //println!("adding {} ([{}][{}]) to the sum",self.store[ ids[i] ][ ids[j] ], ids[i], ids[j] );
                sum += self.euclidean_distance( ids[i], ids[j] );
            }
        }
        //println!("I found ek {sum}");
        sum
    }
    
    /// which rows are in cluster x?
    fn cluster_rows( &self, clus: usize ) -> Vec<usize>{
        let mut ret = Vec::<usize>::with_capacity( self.clusters.len() );
        for i in 0..self.clusters.len(){
             if self.clusters[i] == clus{
                ret.push(i);
             }
        }
        ret
    }
  
```

## The main function

This main function in R now runs the simulated annealing algorithm in R:

```
#This is the main algorithm that performs the annealing. It takes the data,how
#many K we are looking for, The number of iterations to perform, starting
#temperature and the cooling factor.

sa.ok <- function(data,K,Iter,Temp,cool){

  clusters <- sample(1:K,nrow(data),replace = T) #initialise random clusters
  
  #clusters.o <- clusters
  
  Es.old <- calc.E.all(data,clusters)
  #E.old <- E.tot(Es.old)
 
  for(i in 1:Iter){   # start iterating 
    
    clusters.new <- clusters #copy the clusters
    #Es.new <- Es.old
    
    row.id <- sample(1:nrow(data),1) #pick a gene at random
    
    from.c <- clusters.new[row.id] # get the cluster it's moving from
    #to.c <- sample((1:K)[!(1:K) %in% from.c],1)
    to.c <- sample((1:K)[-from.c],1) # randomly choose a new cluster
    
    clusters.new[row.id] <-  to.c # replace the old cluster with the new
    
    Es.new <- Es.old #make a copy of the energies vector
    # calc the energies of the two changed clusters
    Es.new[from.c] <- calc.Ek(data,clusters.new,from.c) 
    Es.new[to.c] <- calc.Ek(data,clusters.new,to.c)
    
    E.new <- E.tot(Es.new) # calculate the new average E
    E.old <- E.tot(Es.old) # calculate the old average E
    
    if(E.new < E.old){  # if new < old accept the move copy the new clusters into the previous
      clusters <-  clusters.new #copy the new clusters into the previous
      Es.old <- Es.new # make Enew to Eold
    }else{
      
      if(calc.exp(E.new,E.old,Temp) > runif(1)){ #evaluate the exprssion against the random number from runif(1)
        clusters <- clusters.new #copy the new clusters into the previous
        Es.old <- Es.new  # make Enew to Eold
      }
    }
    
    {cat("\r",E.old)} #print out the energy to the screen
    
    Temp <- Temp*cool # cool the system
  }
  clusters # return the clusters
}
```

That is quite a lot and we should probably look into what this does.

Since the initial random cluster assignment is already done in new(), we now need to compute the energy of each cluster before proceeding with simulated annealing.

```
    pub fn run( &mut self, max_iter:usize, cool:f32 ) -> usize {
    
      let mut it = 0;
      // calculate the inital energies - this will be modified later
      let mut old_energies= Vec::<f32>::with_capacity( self.k );
      for i in 0..self.k {
          old_energies.push( self.calc_ek( i ) );
      }
      
      let mut old_total: f32 = old_energies.iter().sum::<f32>() / self.k as f32;
      
      let mut rand = rand::rng();
      
      for _ in 0..max_iter{
          it += 1;
          // initate all varaibales
          let mut new_energies = old_energies.clone();
          let moving_row = rand.random_range(0..self.data.len());
          let move_from = self.clusters[moving_row];
          let mut move_to = rand.random_range(0..self.k);
          while move_from == move_to{
              move_to = rand.random_range(0..self.k);
          }
          // move the row from to
          self.clusters[moving_row] = move_to;
          // calculate the new energies
          new_energies[move_from] = self.calc_ek( move_from );
          new_energies[move_to] = self.calc_ek( move_to );
          
          let new_total:u32 = new_energies.iter().sum::<f32>() / self.k as f32;
          
          if new_total < old_total || 
            (-((new_total - old_total) / self.temp)).exp() > rand.random_range(0.0..1.0){
              // that is a good one - keep this
              old_energies[move_from] = new_energies[move_from];
              old_energies[move_to] = new_energies[move_to];
              old_total = new_total;
          }else {
              //this move was not good - drop it!
              self.clusters[moving_row] = move_from;
          }
          // cool the system and exit if it reached ~0
          self.temp *= cool;
          if self.temp < 1e-8{
              break
          }
      }
      it
    }
    
```


## And Funtions to Plot and Write the Data

Here I'll just give you the Rust code as this is something I also just copy pasted:

```
use plotters::prelude::*;
use std::error::Error;
use std::io::Write;

    pub fn write_clusters(&self, ofile: &str, sep: char) -> Result<(), Box<dyn Error>> {
        // Open the file in write mode
        let mut file = File::create(ofile)?;

        // Write the header (optional)
        writeln!(file, "Rowname{}Cluster", sep)?;

        // Iterate over the rownames and clusters, writing them to the file
        for (rowname, cluster) in self.rownames.iter().zip(self.clusters.iter()) {
            writeln!(file, "{}{}{}", rowname, sep, cluster+1)?;
        }

        Ok(())
    }
    
    pub fn plot(&self, prefix:&str )-> Result<(), Box<dyn std::error::Error>> {
        let output_dir = Path::new(prefix).parent().unwrap_or_else(|| Path::new("."));
        std::fs::create_dir_all(output_dir)?;

        for cluster_id in 0..self.k {
            let filename = format!("{}_cluster_{}.png", prefix, cluster_id +1 );
            let root = BitMapBackend::new(&filename, (800, 600)).into_drawing_area();
            root.fill(&WHITE)?;

            let mut chart = ChartBuilder::on(&root)
                .caption(format!("Cluster {}", cluster_id+1), ("sans-serif", 20))
                .margin(20)
                .x_label_area_size(40)
                .y_label_area_size(40)
                .build_cartesian_2d(0..self.data[0].len(), 0.0f32..1.0)?; // Adjust Y range if needed

            chart.configure_mesh().draw()?;

            // Collect all rows belonging to this cluster
            let cluster_data: Vec<&Vec<f32>> = self.data.iter()
                .zip(&self.clusters)
                .filter(|&(_, &c)| c == cluster_id)
                .map(|(row, _)| row)
                .collect();

            // Draw each row as a line plot
            for row in cluster_data {
                chart.draw_series(LineSeries::new(
                    row.iter().enumerate().map(|(x, &y)| (x, y)),
                    &BLUE,
                ))?;
            }

            root.present()?;
            println!("Saved: {}", filename);
        }

        Ok(())
    }

```

The plot function needs one more library:

``` 
cargo add plotters
```

If all has gone well we could improve on our tests!
Add a second test case into the lib.rs file:

```
    #[test]
    fn tes_scale01(){
        let mut obj = SimulatedAnnealing::new( "tests/data/Spellman_Yeast_Cell_Cycle.tsv", 8, 1000.0, '\t' );
        obj.scale_01();
        let exp5:Vec<f32> = vec![0.6989,0.0000,0.0968,0.3333,0.4301,1.0000,0.7419,0.7419,0.6022,0.7634,0.1720,0.4301,0.5161,0.7634,0.6989,0.6559];
        let exp7:Vec<f32> = vec![0.0803,0.0000,0.2867,0.5849,0.9679,1.0000,0.7775,0.7156,0.5505,0.5459,0.4518,0.6193,0.8440,0.8532,0.9335,0.7752];
        let mut dist: f32 = 0.0;
        for i in 0..exp5.len() {
            assert!(
                (obj.data[5][i] - exp5[i]).abs() < 1e-4,
                "Mismatch in gene 5 at index {}: got {}, expected {}",
                i, obj.data[5][i], exp5[i]
            );
            assert!(
                (obj.data[7][i] - exp7[i]).abs() < 1e-4,
                "Mismatch in gene 7 at index {}: got {}, expected {}",
                i, obj.data[7][i], exp7[i]
            );
            dist += (obj.data[7][i]-obj.data[5][i]).powi(2);
        }
        dist = dist.sqrt();
        obj.clusters[5] = 8;
        obj.clusters[7] = 8;
        obj.k =9;
        assert_eq!( obj.calc_ek(8), dist, "the distance in cluster 8 (genes 5 and 7)" );
    }
```


```{bash}
make step3|  sed 's/\x1B\[[0-9;]*m//g'
```

This looks good, just that we can not use this library as we have not implemented the executable :-D 

