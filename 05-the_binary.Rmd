# main.rs

If you compile the library as it is you will not be able to use it.
We need to implement the main.rs file that codes for the binary.

Command line options are normally parsed using the clap crate so we should add that to our project.
This time I want a specific version:

```
cargo add clap@3.0.14 --features derive
```

We need to get the input table, the separation for that table, the number of clusters to search for, the starting tem, cool-down factor and max iteration to run through as well as the file we want to save the clusters to. In Rust you would do this like that:

```
use clap::Parser;

#[derive(Parser)]
#[clap(version = "1.0.0", author = "Stefan L. <stefan.lang@med.lu.se>")]
struct Opts {
    /// the input text table
    #[clap(short, long)]
    file: String,
    /// the column separator for the file
    #[clap(default_value= "\\t",short, long)]
    sep: String,
    /// the number of clusters
    #[clap(short, long)]
    clusters: usize,
    /// the starting temperature
    #[clap(default_value_t= 20.0,short, long)]
    temp: f32,
    /// the cooling factor
    #[clap(default_value_t= 0.9995,short, long)]
    cool: f32,
    ///max number of iterations
    #[clap(default_value_t= 1000*1000,short, long)]
    max_it: usize,
    /// the grouping outfile
    #[clap(short, long)]
    outfile: String,
}

```

This is simple -right?

Add the main function to that script and we are ready to go:

```
use std::time::SystemTime;
// this is specific for my package which I have called simulated_annealing_new as I had an other version, too.
use simulated_annealing::SimulatedAnnealing;

fn main() {
    let now = SystemTime::now();
    
    let opts: Opts = Opts::parse();

    let mut sep = '\t';
    if &opts.sep != "\\t"{
        //println!("I set sep to {}", opts.sep );
        sep = opts.sep.chars().next().unwrap(); 
    }

    let mut sim = SimulatedAnnealing::new( &opts.file, opts.clusters, opts.temp, sep );
    sim.scale_01();    

    //println!("Initial state: {sim}");

    let iterations = sim.run( opts.max_it, opts.cool );

    let _= sim.plot( &opts.outfile );

    //println!("Final state {sim} in {iterations} iterations");

    match sim.write_clusters( &opts.outfile, sep ){
        Ok(_) => println!("Clusters written to {}", &opts.outfile ),
        Err(e) => eprintln!("Failed to write the data to {}: {:?}", &opts.outfile, e),
    }

    match now.elapsed() {
        Ok(elapsed) => {
            let mut milli = elapsed.as_millis();

            let mil = milli % 1000;
            milli= (milli - mil) /1000;

            let sec = milli % 60;
            milli= (milli -sec) /60;

            let min = milli % 60;
            milli= (milli -min) /60;

            eprintln!("finished in {milli} h {min} min {sec} sec {mil} milli sec");
        },
        Err(e) => {println!("Error: {e:?}");}
    }
}

```

The main function is very simple - halve of it is actually calculating the time the program takes to finish.
Try it?

```{bash}
make step4 |  sed 's/\x1B\[[0-9;]*m//g'
```

## We Have an Executable!!

You now can run the executable target/release/simulated_annealing like that:

```{bash}
#I need to go to another directory - you stay where you are:
cd rust_stages/step4

#and run the script:
target/release/simulated_annealing  -f tests/data/Spellman_Yeast_Cell_Cycle.tsv --clusters 8 --temp 20 --outfile /tmp/clusters.tsv
```

## Implement a 'print' for our Class

The output from this program lacks. We would like to know how the energies of the system were in the beginning and the end.

To implement that we need this in our library file, not the impl block:

```
use std::fmt;

impl fmt::Display for SimulatedAnnealing {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut sum = 0.0_f32;
        for i in 0..self.k {
            sum += self.calc_ek( i );
        }
        sum /= self.k as f32;
        write!(f, "SimulatedAnnealing (temperature: {:.2} and total energy {:.2} for {} clusters):\n", self.temp, sum , self.k )
  }
}
```

Afterwards we can change our main.rs and add the print statements:

```
fn main() {
    let now = SystemTime::now();
    
    let opts: Opts = Opts::parse();

    let mut sep = '\t';
    if &opts.sep != "\\t"{
        //println!("I set sep to {}", opts.sep );
        sep = opts.sep.chars().next().unwrap(); 
    }

    let mut sim = SimulatedAnnealing::new( &opts.file, opts.clusters, opts.temp, sep );
    sim.scale_01();    

    println!("Initial state: {sim}");

    let iterations = sim.run( opts.max_it, opts.cool );

    let _= sim.plot( &opts.outfile );

    println!("Final state {sim} after {iterations} iterations");

    match sim.write_clusters( &opts.outfile, sep ){
        Ok(_) => println!("Clusters written to {}", &opts.outfile ),
        Err(e) => eprintln!("Failed to write the data to {}: {:?}", &opts.outfile, e),
    }

    match now.elapsed() {
        Ok(elapsed) => {
            let mut milli = elapsed.as_millis();

            let mil = milli % 1000;
            milli= (milli - mil) /1000;

            let sec = milli % 60;
            milli= (milli -sec) /60;

            let min = milli % 60;
            milli= (milli -min) /60;

            eprintln!("finished in {milli} h {min} min {sec} sec {mil} milli sec");
        },
        Err(e) => {println!("Error: {e:?}");}
    }
}
```

I have not modified my examples here - so this is something y<ou can do all for yourself.
If we have more time we could implement one more improvement to the library:

Add a store variable into the system and calculate the row to row distances after you have scaled the data.
Then modify the calc_ek() function to use the values from the store and not calculate the distances every single time.
This should give you an additional x5 speed improvement.

## Take Home Message

The implementation of the functions is significantly different from R or Python, but with the compiler and the AI assistance we can get at the moment it is doable. It takes time to get into, but the speed improvements can be enormous.

This example here does not really highlight the usability, but if you have more complicated tasks - like processing bam files or anything else that is either easy to implement in a multiprocessor system or needs to process binary data it is worth to look into Rust. It is significantly slower than C and C++ (like 3 to 5 times?), but it is so much easier to program in if you come from R and Python - it is worth it.

By the way - even with the store this implementation is about 50\% slower than another implementation I used before where the data was not stored in a Vec<Vec<f32>> but a more complicated single Vector (precicely a ArrayBase<ndarray::OwnedRepr<f64>, Dim<[usize; 2]>>). But for the sake of this tutorial I think a Vec<Vec<_>> is easier to work with. You can check out my other implementation [here](https://github.com/stela2502/simulated_annealing).


