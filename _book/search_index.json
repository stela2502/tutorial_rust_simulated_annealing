[["variables---strict-types-and-ownership-in-rust.html", "Chapter 2 Variables - Strict Types and Ownership in Rust 2.1 Strict Types in Rust 2.2 Ownership in Rust 2.3 Combining Types and Ownership 2.4 Summary of Ownership and Strict Types:", " Chapter 2 Variables - Strict Types and Ownership in Rust 2.1 Strict Types in Rust Rust is a statically typed language, meaning you must define the types of variables and data structures explicitly. This ensures type safety at compile time. 2.1.1 Example 1: Strict Typing in Rust Let’s start by defining variables with specific types: fn main() { let integer: i32 = 10; // 32-bit signed integer let floating_point: f64 = 10.5; // 64-bit floating-point number let boolean: bool = true; // Boolean value println!(&quot;Integer: {}, Floating-point: {}, Boolean: {}&quot;, integer, floating_point, boolean); // Uncomment the below line to see what happens when types don&#39;t match // let incorrect_type: i32 = 10.5; // ERROR: mismatched types } 2.1.1.1 What happens here? Rust expects each variable to be of the specified type (i32, f64, bool). If you try to assign a value with an incompatible type (e.g., 10.5 to an i32), the compiler will throw an error. If you uncomment the incorrect_type line, the compiler will catch it: error[E0308]: mismatched types --&gt; src\\main.rs:8:9 | 8 | let incorrect_type: i32 = 10.5; | ^^^^^^^^^^^^^^ expected integer, found floating-point number This strict checking ensures type safety and helps avoid runtime errors related to type mismatches. 2.1.1.2 Key Points: Rust enforces type correctness at compile time. You cannot implicitly convert between types (like R or Python might allow). Explicit type annotations help prevent unintended errors and increase code clarity. 2.2 Ownership in Rust One of Rust’s most important and unique features is its ownership model. It ensures memory safety by enforcing strict rules about who owns data and when data is dropped (freed). 2.2.1 Ownership Rules in Rust: Each value in Rust has a single owner. When the owner goes out of scope, Rust automatically frees the memory. You cannot have more than one owner at a time. If you want to transfer ownership, you use borrowing or cloning. 2.2.2 Example 2: Ownership in Rust Let’s look at a simple example that demonstrates ownership. fn main() { let s1 = String::from(&quot;Hello, Rust!&quot;); // s1 owns the String let s2 = s1; // Ownership of the String is moved from s1 to s2 // println!(&quot;{}&quot;, s1); // ERROR: s1 is no longer valid println!(&quot;{}&quot;, s2); // This works, since s2 is the owner now // After s2 goes out of scope, the memory will be freed. } 2.2.2.1 Explanation: s1 is the owner of the String object. When s1 is assigned to s2, ownership of the String is moved from s1 to s2. After the move, s1 is no longer valid, and trying to use it (e.g., println!(\"{}\", s1)) will result in a compiler error: error[E0382]: use of moved value: `s1` --&gt; src\\main.rs:7:22 | 7 | println!(&quot;{}&quot;, s1); // ERROR: value moved, cannot use | ^^^ value moved here This behavior is critical because it ensures that Rust doesn’t accidentally create multiple owners of the same data (which could lead to data races or memory leaks). 2.2.3 Example 3: Borrowing in Rust Rust allows you to borrow data, either immutably or mutably. fn main() { let s1 = String::from(&quot;Hello, Rust!&quot;); // s1 owns the String // Immutable Borrowing let s2 = &amp;s1; // s2 borrows s1 immutably println!(&quot;{}&quot;, s2); // This works because s2 is just borrowing s1 // Mutable Borrowing let mut s3 = String::from(&quot;Mutable borrow!&quot;); let s4 = &amp;mut s3; // s4 borrows s3 mutably s4.push_str(&quot; Now it’s mutable!&quot;); println!(&quot;{}&quot;, s4); // Prints: Mutable borrow! Now it’s mutable! // You can&#39;t have both mutable and immutable borrows at the same time: // let s5 = &amp;s1; // ERROR: cannot borrow `s1` as immutable because it&#39;s already borrowed as mutable } 2.2.3.1 Explanation: Immutable borrowing (let s2 = &amp;s1) allows multiple references to the same data but doesn’t allow modification. Mutable borrowing (let s4 = &amp;mut s3) gives exclusive access to the data, and no other borrows (immutable or mutable) can exist while it’s borrowed mutably. The rules prevent data races by ensuring no one can have mutable access while others are reading (or mutably accessing the data). 2.3 Combining Types and Ownership Let’s combine both strict typing and ownership in a small example where we use both concepts together. fn main() { let num: i32 = 42; // i32 type (strict typing) let num_copy = num; // Ownership of num is copied to num_copy (as num is Copy type) println!(&quot;num: {}, num_copy: {}&quot;, num, num_copy); // Both can still be used let s1 = String::from(&quot;Rust Ownership!&quot;); // String type (non-Copy type) let s2 = s1; // Ownership of s1 is moved to s2 // println!(&quot;{}&quot;, s1); // ERROR: s1 is no longer valid println!(&quot;{}&quot;, s2); // This works, since s2 now owns the String } 2.3.1 Output: num: 42, num_copy: 42 Rust Ownership! Copy types (like i32) do not move ownership. They duplicate the data when assigned to another variable. Non-copy types (like String) move ownership when assigned to another variable, which makes the first variable invalid. 2.4 Summary of Ownership and Strict Types: Rust’s strict typing ensures type safety at compile time, preventing mismatched types and logic errors that would only be caught at runtime in languages like R or Python. Rust’s ownership model prevents issues like double freeing of memory and data races, making it one of the safest systems languages available. The rules around ownership, borrowing, and moving data are central to memory management in Rust, giving developers fine-grained control over memory safety without a garbage collector. Even so will not face these problems today it’s extremely important to know about this before you try to program in Rust. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
