[["using-rust-to-implement-the-simulated-annealing-algorithm.html", "Simulated Annealing in Rust Chapter 1 Using Rust to Implement the Simulated Annealing Algorithm 1.1 Rust vs.¬†R: Key Differences 1.2 A Quick Refresher: Object-Oriented Programming (OO) 1.3 The Problem: Clustering Expression Data Using Simulated Annealing 1.4 Simulated annealing 1.5 The Algorithm", " Simulated Annealing in Rust Stefan Lang 2025-04-11 Chapter 1 Using Rust to Implement the Simulated Annealing Algorithm This tutorial is for experienced bioinformaticians who have been programming in R and/or Python, or other scripting languages. If you have experience with C, C++, or Julia, that will also be beneficial. While R is widely used in bioinformatics for statistical analysis and data manipulation, Rust is a systems programming language that provides strong type safety, memory safety without garbage collection, and high performance. This tutorial will introduce key differences between R and Rust and guide you through implementing a simulated annealing algorithm in Rust. 1.1 Rust vs.¬†R: Key Differences Before diving into the implementation, let‚Äôs highlight a few fundamental differences between R and Rust that will be important for this tutorial: Feature R (Scripting Language) Rust (Systems Language) Typing Dynamic (e.g., x &lt;- 10 can later be x &lt;- \"text\") Static (types must be defined, e.g., let x: i32 = 10;) Memory Management Garbage collection Ownership and borrowing Performance Optimized for high-level analysis Compiled, low-level efficiency Object-Oriented Features R has S3, S4, and R6 classes but isn‚Äôt purely OO Rust supports structs and traits for OO-like behavior Concurrency Limited parallel processing Strong concurrency model with async and threads Understanding these differences will help when translating concepts from R to Rust. 1.2 A Quick Refresher: Object-Oriented Programming (OO) Although R is not strictly an object-oriented language, it does support OO through S3, S4, and R6 classes. Rust, on the other hand, does not have traditional classes like Python or Java but instead uses structs and traits to achieve similar functionality. Here‚Äôs a quick comparison of how objects and methods are implemented in R and Rust: 1.2.1 R Example: Object-Oriented Approach Using S3 # Define an S3 object cluster &lt;- list(centroid = c(2.3, 3.4), members = c(1, 5, 9)) class(cluster) &lt;- &quot;Cluster&quot; # Define a method for the Cluster class print.Cluster &lt;- function(obj) { cat(&quot;Cluster centroid at:&quot;, obj$centroid, &quot; &quot;) } # Use the method print(cluster) 1.2.2 Rust Equivalent: Using Structs and Traits struct Cluster { centroid: (f64, f64), members: Vec&lt;u32&gt;, } impl Cluster { fn print(&amp;self) { println!(&quot;Cluster centroid at: {:?}&quot;, self.centroid); } } fn main() { let cluster = Cluster { centroid: (2.3, 3.4), members: vec![1, 5, 9], }; cluster.print(); } 1.2.3 Key Takeaways R uses lists and S3/S4 classes for OO design, whereas Rust uses structs and traits. Methods in R are just functions that check an object‚Äôs class, while Rust uses impl blocks to define methods. Rust enforces type safety at compile time, while R allows more flexibility at the cost of runtime type checking. 1.3 The Problem: Clustering Expression Data Using Simulated Annealing The algorithm we will implement is based on an R programming exercise given to students. It clusters gene expression data using simulated annealing, a probabilistic optimization method. This algorithm is simple to understand and implement, but it also touches on several important programming concepts, including: - File reading - Control flow (loops, conditionals) - Data structures (vectors, matrices, hashes) - Mathematical operations - Performance considerations 1.3.1 The Data For this problem, we will use yeast cell-cycle data, which is a small time-course dataset consisting of 250 genes across 16 timepoints. The data is available here: üîó Spellman_Yeast_Cell_Cycle.tsv 1.3.1.1 Biological Context Yeast in liquid culture were synchronized at the same cell-cycle phase and then released. They underwent two synchronized divisions, and samples were taken at 16 timepoints. Since genes involved in the same biological processes tend to have similar expression patterns, this dataset contains distinct clusters of co-regulated genes. Our task is to cluster genes based on their expression profiles using simulated annealing. 1.4 Simulated annealing We can think of well clustered data having low energy, in that each cluster is tight and has little within cluster variance. If we calculate the variance within each cluster and sum over all clusters we get the total variance (energy) of the system. To measure the distance between two genes \\(i\\) and \\(j\\) over \\(t\\) timepoints we do: \\[d_{ij}=\\sqrt{\\sum{(g^{i}_t-g^{j}_t)^2}}\\] so to measure the energy (total variance) of a clustering we sum the pairwise distances for each cluster \\(K\\), and then sum over all \\(K\\)s and them divide by \\(K\\). \\[ E(K)=\\frac{1}{K}\\sum^K_{k=1} \\left[ \\sum_{i\\epsilon Ck}\\sum_{j\\epsilon Ck} d_{ij}\\right] \\] For a well clustered data, \\(E(K)\\) should be as small as possible. Lets say we have 1000 genes, and we want to partition them into 10 clusters. The number of combinations is too high for us to try each one to brute force a true \\(E\\). This is why we use a heuristic algorithm to get us as close to the solution as possible in a smaller amount of time. If we tried to visualise the energy landscape we can imagine it might look something like this: The idea behind simulated annealing is that ‚Äúbad‚Äù moves are also allowed for a proportion of the iterations allowing exploration of the energy landscape, thereby avoiding local minima. 1.5 The Algorithm I do not want to focus too much onto the algoirithm here as the main focus is on the Rust implementation, but the steps that need to be run are as follows: Load the data and scale it so each gene‚Äôs value lie between 0 and 1 Create a random cluster information and calculate the energy of this clustering Randomly shift any gene from it‚Äôs cluster to another Calculate the new energy and check if the new cluster info should be kept; do that Repeat 3 and 4 for n iterations report the cluster information - if possible create plots And all of that in Rust ;-) Next ‚û°Ô∏è "],["variables---strict-types-and-ownership-in-rust.html", "Chapter 2 Variables - Strict Types and Ownership in Rust 2.1 Strict Types in Rust 2.2 Ownership in Rust 2.3 Combining Types and Ownership 2.4 Summary of Ownership and Strict Types:", " Chapter 2 Variables - Strict Types and Ownership in Rust 2.1 Strict Types in Rust Rust is a statically typed language, meaning you must define the types of variables and data structures explicitly. This ensures type safety at compile time. 2.1.1 Example 1: Strict Typing in Rust Let‚Äôs start by defining variables with specific types: fn main() { let integer: i32 = 10; // 32-bit signed integer let floating_point: f64 = 10.5; // 64-bit floating-point number let boolean: bool = true; // Boolean value println!(&quot;Integer: {}, Floating-point: {}, Boolean: {}&quot;, integer, floating_point, boolean); // Uncomment the below line to see what happens when types don&#39;t match // let incorrect_type: i32 = 10.5; // ERROR: mismatched types } 2.1.1.1 What happens here? Rust expects each variable to be of the specified type (i32, f64, bool). If you try to assign a value with an incompatible type (e.g., 10.5 to an i32), the compiler will throw an error. If you uncomment the incorrect_type line, the compiler will catch it: error[E0308]: mismatched types --&gt; src\\main.rs:8:9 | 8 | let incorrect_type: i32 = 10.5; | ^^^^^^^^^^^^^^ expected integer, found floating-point number This strict checking ensures type safety and helps avoid runtime errors related to type mismatches. 2.1.1.2 Key Points: Rust enforces type correctness at compile time. You cannot implicitly convert between types (like R or Python might allow). Explicit type annotations help prevent unintended errors and increase code clarity. 2.2 Ownership in Rust One of Rust‚Äôs most important and unique features is its ownership model. It ensures memory safety by enforcing strict rules about who owns data and when data is dropped (freed). 2.2.1 Ownership Rules in Rust: Each value in Rust has a single owner. When the owner goes out of scope, Rust automatically frees the memory. You cannot have more than one owner at a time. If you want to transfer ownership, you use borrowing or cloning. 2.2.2 Example 2: Ownership in Rust Let‚Äôs look at a simple example that demonstrates ownership. fn main() { let s1 = String::from(&quot;Hello, Rust!&quot;); // s1 owns the String let s2 = s1; // Ownership of the String is moved from s1 to s2 // println!(&quot;{}&quot;, s1); // ERROR: s1 is no longer valid println!(&quot;{}&quot;, s2); // This works, since s2 is the owner now // After s2 goes out of scope, the memory will be freed. } 2.2.2.1 Explanation: s1 is the owner of the String object. When s1 is assigned to s2, ownership of the String is moved from s1 to s2. After the move, s1 is no longer valid, and trying to use it (e.g., println!(\"{}\", s1)) will result in a compiler error: error[E0382]: use of moved value: `s1` --&gt; src\\main.rs:7:22 | 7 | println!(&quot;{}&quot;, s1); // ERROR: value moved, cannot use | ^^^ value moved here This behavior is critical because it ensures that Rust doesn‚Äôt accidentally create multiple owners of the same data (which could lead to data races or memory leaks). 2.2.3 Example 3: Borrowing in Rust Rust allows you to borrow data, either immutably or mutably. fn main() { let s1 = String::from(&quot;Hello, Rust!&quot;); // s1 owns the String // Immutable Borrowing let s2 = &amp;s1; // s2 borrows s1 immutably println!(&quot;{}&quot;, s2); // This works because s2 is just borrowing s1 // Mutable Borrowing let mut s3 = String::from(&quot;Mutable borrow!&quot;); let s4 = &amp;mut s3; // s4 borrows s3 mutably s4.push_str(&quot; Now it‚Äôs mutable!&quot;); println!(&quot;{}&quot;, s4); // Prints: Mutable borrow! Now it‚Äôs mutable! // You can&#39;t have both mutable and immutable borrows at the same time: // let s5 = &amp;s1; // ERROR: cannot borrow `s1` as immutable because it&#39;s already borrowed as mutable } 2.2.3.1 Explanation: Immutable borrowing (let s2 = &amp;s1) allows multiple references to the same data but doesn‚Äôt allow modification. Mutable borrowing (let s4 = &amp;mut s3) gives exclusive access to the data, and no other borrows (immutable or mutable) can exist while it‚Äôs borrowed mutably. The rules prevent data races by ensuring no one can have mutable access while others are reading (or mutably accessing the data). 2.3 Combining Types and Ownership Let‚Äôs combine both strict typing and ownership in a small example where we use both concepts together. fn main() { let num: i32 = 42; // i32 type (strict typing) let num_copy = num; // Ownership of num is copied to num_copy (as num is Copy type) println!(&quot;num: {}, num_copy: {}&quot;, num, num_copy); // Both can still be used let s1 = String::from(&quot;Rust Ownership!&quot;); // String type (non-Copy type) let s2 = s1; // Ownership of s1 is moved to s2 // println!(&quot;{}&quot;, s1); // ERROR: s1 is no longer valid println!(&quot;{}&quot;, s2); // This works, since s2 now owns the String } 2.3.1 Output: num: 42, num_copy: 42 Rust Ownership! Copy types (like i32) do not move ownership. They duplicate the data when assigned to another variable. Non-copy types (like String) move ownership when assigned to another variable, which makes the first variable invalid. 2.4 Summary of Ownership and Strict Types: Rust‚Äôs strict typing ensures type safety at compile time, preventing mismatched types and logic errors that would only be caught at runtime in languages like R or Python. Rust‚Äôs ownership model prevents issues like double freeing of memory and data races, making it one of the safest systems languages available. The rules around ownership, borrowing, and moving data are central to memory management in Rust, giving developers fine-grained control over memory safety without a garbage collector. Even so will not face these problems today it‚Äôs extremely important to know about this before you try to program in Rust. ‚¨ÖÔ∏è PreviousNext ‚û°Ô∏è "],["create-a-rust-project-and-implement-the-class.html", "Chapter 3 Create a Rust Project and Implement the Class 3.1 For the class - which data structures do we need? 3.2 Function Overview 3.3 Breaking It Down 3.4 Adding a Test for read_table_with_names 3.5 Implementing a Unit Test", " Chapter 3 Create a Rust Project and Implement the Class A Rust class is a combination of a struct- (data) and an impl-block (functions). But as in R a Rust package contains several other important files and a specific folder structure. As an R programmer, you‚Äôre likely familiar with using tools like devtools to streamline the creation of R packages. In Rust, the process of setting up a new package is just as straightforward, though the terminology and structure differ slightly. This will create the folder, populate it with some files and prepare it for git usage. cargo new --bin simulated_annealing For later use we create a simulated_annealing/tests folder and a simulated_annealing/src/lib.rs file. I normally put as much code into the library and keep the script as slender as possible. 3.1 For the class - which data structures do we need? The ‚Äòexpression‚Äô data The rows &lt;-&gt; cluster connections The number of clusters asked for The actual temperature of the system ** Let‚Äôs create the object** Open the src/lib.rs file and add this: pub struct SimulatedAnnealing { /// the normalized expression data pub data: Vec&lt;Vec&lt;f32&gt;&gt;, /// the names for each row rownames: Vec&lt;String&gt;, /// the cluster ids for each row of data clusters: Vec&lt;usize&gt;, /// expected clusters k k: usize, /// the actual temerature temp:f32, } impl SimulatedAnnealing { pub fn new( file_path:&amp;str, k:usize, temp:f32, split:char ) -&gt; Self{ let (rownames, data) = Self::read_table_with_names( file_path, split ).unwrap(); let clusters: Vec&lt;usize&gt; = rownames.iter().map(|_| rand::thread_rng().gen_range(1..=k)).collect(); Self{ data, rownames, clusters, clusters_energy: vec![0.0; k ], temp, } } } This will define a class with the variables data, rownames, clusters, k and temp as well as the new() function for this class, which in turn populates these variables with initial values. Save the file and try to compile your project using cargo test -r ## make[1]: Verzeichnis ‚Äû/home/med-sal/git_Projects/tutorial_rust_simulated_annealing‚Äú wird betreten ## Building /home/med-sal/git_Projects/tutorial_rust_simulated_annealing/rust_stages/step1... ## Compiling simulated_annealing v0.1.0 (/home/med-sal/git_Projects/tutorial_rust_simulated_annealing/rust_stages/step1) ## error[E0599]: no function or associated item named `read_table_with_names` found for struct `SimulatedAnnealing` in the current scope ## --&gt; src/lib.rs:21:38 ## | ## 2 | pub struct SimulatedAnnealing { ## | ----------------------------- function or associated item `read_table_with_names` not found for this struct ## ... ## 21 | let (rownames, data) = Self::read_table_with_names( file_path, split ).unwrap(); ## | ^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SimulatedAnnealing` ## | ## note: if you&#39;re trying to build a new `SimulatedAnnealing`, consider using `SimulatedAnnealing::new` which returns `SimulatedAnnealing` ## --&gt; src/lib.rs:19:5 ## | ## 19 | pub fn new( file_path:&amp;str, k:usize, temp:f32, split:char ) -&gt; Self{ ## | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ## ## error[E0433]: failed to resolve: use of undeclared crate or module `rand` ## --&gt; src/lib.rs:23:60 ## | ## 23 | let clusters: Vec&lt;usize&gt; = rownames.iter().map(|_| rand::thread_rng().gen_range(0..k)).collect(); ## | ^^^^ use of undeclared crate or module `rand` ## ## Some errors have detailed explanations: E0433, E0599. ## For more information about an error, try `rustc --explain E0433`. ## error: could not compile `simulated_annealing` (lib) due to 2 previous errors ## warning: build failed, waiting for other jobs to finish... ## error: could not compile `simulated_annealing` (lib test) due to 2 previous errors ## Finished building /home/med-sal/git_Projects/tutorial_rust_simulated_annealing/rust_stages/step1. Logs are in step1_build.log ## make[1]: Verzeichnis ‚Äû/home/med-sal/git_Projects/tutorial_rust_simulated_annealing‚Äú wird verlassen Right - we try to create the random cluster info and have not loaded the required package. That is simple to do in Rust: cargo add rand Do not forget to also load that library into the lib.rs. I the top of that file add use rand::Rng;. The read_table function is more complicated. I normally out-source these simple, but tedious steps to ChatGPT or an other AI helper, but these are the steps we need to take: create a Path from the &amp;str file_name open that Path create a BuffReader from that File to more efficiently read from it iterate over the lines and split the line by sep (could be user defined too - or?) use the first entry as rowname (String) and the rest as numeric (f32). To fix the issues you need to add this in at the beginning of the lib.rs file use std::path::Path; use std::fs::File; use std::io::{BufReader, BuffRead}; use rand::Rng; And the following rust function into the impl block. pub fn read_table_with_names(file_path: &amp;str, split: char ) -&gt; Result&lt;( Vec&lt;String&gt;, Vec&lt;Vec&lt;f32&gt;&gt;), String&gt; { let path = Path::new(file_path); let file = match File::open(path){ Ok(f) =&gt; f, Err(e) =&gt; { return Err( format!(&quot;Failed to open file: {}&quot;, e) ) } }; let reader = BufReader::new(file); let mut data = Vec::new(); let mut rownames= Vec::new(); for (line_num, line) in reader.lines().enumerate() { let line = line.map_err(|e| format!(&quot;Error reading line {}: {}&quot;, line_num + 1, e))?; let mut parts = line.split( split ); let row_name = parts.next().ok_or_else(|| format!(&quot;Missing row name at line {}&quot;, line_num + 1))?; if row_name == &quot;&quot; { // ignore column names continue; } rownames.push( row_name.to_string() ); let values: Result&lt;Vec&lt;f32&gt;, String&gt; = parts .map(|num| num.parse::&lt;f32&gt;().map_err(|_| format!(&quot;Invalid number &#39;{}&#39; at line {}&quot;, num, line_num + 1))) .collect(); let values = values.unwrap(); // will die on error data.push( values ); } Ok( (rownames,data) ) } Understanding read_table_with_names If you‚Äôre an R developer, think of it as a combination of read.table() with custom handling for row names and numeric conversion. 3.2 Function Overview 3.2.1 Function Signature pub fn read_table_with_names(file_path: &amp;str, split: char ) -&gt; Result&lt;( Vec&lt;String&gt;, Vec&lt;Vec&lt;f32&gt;&gt;), String&gt; This function: - Takes a file path (file_path: &amp;str) as a string reference. - Accepts a delimiter character (split: char) to separate values. - Returns a Result type containing either: - A tuple of row names (Vec&lt;String&gt;) and numeric data matrix (Vec&lt;Vec&lt;f32&gt;&gt;). - Or an error message (String) in case of failure. 3.3 Breaking It Down 3.3.1 Step 1: Open the File let path = Path::new(file_path); let file = match File::open(path){ Ok(f) =&gt; f, Err(e) =&gt; { return Err(format!(&quot;Failed to open file: {}&quot;, e)); } }; What it does: - Converts file_path into a Path object. - Tries to open the file using File::open(path). If successful, it assigns the file handle to f. - If the file opening fails, it returns an error message. R Equivalent: if (!file.exists(file_path)) { stop(paste(&quot;Failed to open file:&quot;, file_path)) } 3.3.2 Step 2: Prepare the Variables let reader = BufReader::new(file); let mut data = Vec::new(); let mut rownames = Vec::new(); What it does: - Wraps the file handle in BufReader for efficient line-by-line reading. - Initializes empty vectors: - data: Stores numeric values (like a matrix in R). - rownames: Stores row names. 3.3.3 Step 3: Parse Each Line for (line_num, line) in reader.lines().enumerate() { let line = line.map_err(|e| format!(&quot;Error reading line {}: {}&quot;, line_num + 1, e))?; let mut parts = line.split(split); What it does: - Iterates over each line, keeping track of line numbers. - Splits the line into separate values based on split (e.g., \\t for TSV, , for CSV). - Handles file reading errors gracefully. 3.3.4 Step 4: Extract Row Names let row_name = parts.next().ok_or_else(|| format!(&quot;Missing row name at line {}&quot;, line_num + 1))?; if row_name == &quot;&quot; { continue; // Ignore column names } rownames.push(row_name.to_string()); What it does: - Retrieves the first value from the line as the row name. - If no row name is found, it returns an error. - Skips empty row names (useful for ignoring headers). - Adds valid row names to rownames. R Equivalent: data &lt;- read.table(file_path, sep=&quot;\\t&quot;, header=TRUE, row.names=1) rownames &lt;- rownames(data) 3.3.5 Step 5: Convert Remaining Values to f32 let values: Result&lt;Vec&lt;f32&gt;, String&gt; = parts .map(|num| num.parse::&lt;f32&gt;().map_err(|_| format!(&quot;Invalid number &#39;{}&#39; at line {}&quot;, num, line_num + 1))) .collect(); let values = values.unwrap(); data.push(values); What it does: - Attempts to convert each remaining value in the row into f32. - If a value is invalid, an error message is returned. - Pushes the successfully parsed row into data. R Equivalent: data_matrix &lt;- as.matrix(data) data_matrix &lt;- apply(data_matrix, 2, as.numeric) # Convert to numeric 3.3.6 Step 6: Return the Parsed Data Ok((rownames, data)) If everything succeeds, returns a tuple: (row names, numeric matrix). The Result type ensures proper error handling. 3.3.7 Why are there so many ways to create the error? In short Rust has two classes to handle errors: a Result that allows for an error being returned if something fails and a Option which only allows None to be returned if something fails. If you want more details to that you can read on here 6. So if we re-compile this - will it work? If not just follow the compiler‚Äôs help ;-) 3.4 Adding a Test for read_table_with_names Why Testing Matters Currently, our function compiles, but without a test, we cannot verify correctness. Unit testing ensures the function behaves as expected under various conditions. 3.5 Implementing a Unit Test Unit tests should be included at the end of the same file where the function is defined - there they can access private functions and variables of the class. #[cfg(test)] mod tests { use super::*; // Import everything from the parent module #[test] fn test_read_data() { match read_table_with_names(&quot;tests/data/Spellman_Yeast_Cell_Cycle.tsv&quot;, &#39;\\t&#39;) { Ok((rownames, data)) =&gt; { assert_eq!(data.len(), 256, &quot;Expected 256 rows&quot;); assert_eq!(data[0].len(), 16, &quot;Expected 16 columns&quot;); assert_eq!(rownames.len(), data.len(), &quot;Row names should match row count&quot;); } Err(e) =&gt; { panic!(&quot;Could not read the TSV file: {e}&quot;); } } } } 3.5.1 Explanation Uses Rust‚Äôs built-in testing framework (#[test] attribute). Calls read_table_with_names() with a sample TSV file. Asserts expected row and column counts, ensuring data integrity. Panics with an error message if file reading fails. By adding this test, we verify that our function properly reads tabular data and correctly extracts row names and numeric values. I have a complete chapter on testing in Rust: 7. For this to work we need to create the folder in our package and download this file there. mkdir -p tests/data wget https://github.com/shambam/R_programming_1/raw/refs/heads/main/Spellman_Yeast_Cell_Cycle.tsv -O tests/data/Spellman_Yeast_Cell_Cycle.tsv Now you can compile and test that the file is read correctly: cargo test -r ## make[1]: Verzeichnis ‚Äû/home/med-sal/git_Projects/tutorial_rust_simulated_annealing‚Äú wird betreten ## Building /home/med-sal/git_Projects/tutorial_rust_simulated_annealing/rust_stages/step2... ## Finished `release` profile [optimized] target(s) in 0.06s ## Running unittests src/lib.rs (target/release/deps/simulated_annealing-ec0f849373011f09) ## ## running 1 test ## test tests::test_read_data ... ok ## ## test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Running unittests src/main.rs (target/release/deps/simulated_annealing-34887cf23462f205) ## ## running 0 tests ## ## test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Running tests/test-SimulatedAnnealing.rs (target/release/deps/test_SimulatedAnnealing-fd16fac0ecee9aa3) ## ## running 1 test ## test test_simulated_annealing ... ok ## ## test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Doc-tests simulated_annealing ## ## running 0 tests ## ## test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Finished building /home/med-sal/git_Projects/tutorial_rust_simulated_annealing/rust_stages/step2. Logs are in step2_build.log ## make[1]: Verzeichnis ‚Äû/home/med-sal/git_Projects/tutorial_rust_simulated_annealing‚Äú wird verlassen Cool! First class first class function and first test - and everything is working - or? Lets also add a test for the new() function. This function should be accessible from outside and therefore we should create a new test file. Create the file tests/test-SimulatedAnnealing.rs and fill it with this: use simulated_annealing::SimulatedAnnealing; // Replace `my_crate` with your actual crate name #[test] fn test_simulated_annealing() { let sa = SimulatedAnnealing::new( &quot;tests/data/Spellman_Yeast_Cell_Cycle.tsv&quot;, 10, 200.0, &#39;\\t&#39; ); assert_eq!(sa.data.len(), 256, &quot;we have 256 rows&quot;); assert_eq!(sa.data[0].len(), 16, &quot;we have 16 cols&quot;); } Test this again. So all that is left is to implement the main simulated annealing algorithm! ‚¨ÖÔ∏è PreviousNext ‚û°Ô∏è "],["implement-the-simulated-annealing-algorithm.html", "Chapter 4 Implement the Simulated Annealing Algorithm 4.1 scaling of the data or ‚Äúwhy scale.01 in R is Fundamentally Flawed‚Äù 4.2 The Rust Approach 4.3 Calculating Cluster Energy 4.4 The Rust Implementation 4.5 The main worker function 4.6 And Funtions to Plot and Write the Data", " Chapter 4 Implement the Simulated Annealing Algorithm The idea behind this workshop is not to teach you how to implement the simulated annealing algorithm, but to show you how you can start to use Rust. Therefore we will use Shamit‚Äôs R implementation and convert that to Rust. 4.1 scaling of the data or ‚Äúwhy scale.01 in R is Fundamentally Flawed‚Äù 4.1.1 The R Implementation The scale.01 function in R is defined as follows: scale.01 &lt;- function(v){ sc.01 &lt;- (v - min(v)) / (max(v) - min(v)) sc.01 } At first glance, this function seems to be a simple and effective way to scale a vector of numerical values between 0 and 1. And to state that clearly - it is perfectly valid R code. However, there are several fundamental issues with this implementation. 4.1.2 The Problems with scale.01 Inefficiency: The function computes min(v) and max(v) twice. This is unnecessary and can significantly slow down performance when applied to large vectors. Vectorized but Inefficient in Apply Calls: The function is designed to be used in an apply() statement, which is idiomatic in R. However, repeatedly calling this function on subsets of data results in redundant computations. Mutation vs.¬†Copying: In R, this function creates a new vector instead of modifying the existing one in place. This is inefficient for large datasets and contrasts with best practices in languages like Rust. 4.2 The Rust Approach In Rust, the equivalent function would modify the existing data structure in place for efficiency. Here‚Äôs an example: pub fn scale_01(&amp;mut self) { for row in &amp;mut self.data { let mut min = f32::INFINITY; let mut max = f32::NEG_INFINITY; for &amp;value in row.iter() { min = min.min(value); max = max.max(value); } for value in row.iter_mut() { *value = (*value - min) / (max - min); } } } 4.2.1 Why the Rust Approach is Better In-Place Modification: The Rust function modifies the existing data structure instead of creating unnecessary copies. Optimized Min/Max Computation: The min and max values are computed only once per row, avoiding redundant calculations. Memory Efficiency: By avoiding extra allocations, the Rust implementation is more memory-efficient, making it suitable for large datasets. Safety &amp; Performance: Rust enforces strict memory safety and avoids unintended data duplication, unlike R, where copies can be created implicitly. 4.2.2 Summary R makes vectorized operations look simple but hides inefficiencies. Rust requires explicit memory management but ensures better performance and correctness. 4.3 Calculating Cluster Energy The R function calc.Ek calculates the energy of a specific cluster in a dataset. Here‚Äôs the R code: calc.Ek &lt;- function(m, clus, coi){ clus.d &lt;- m[which(clus == coi), ] Ek &lt;- sum(dist(clus.d)) Ek } 4.3.1 Explanation of the R Code Selecting Rows for the Cluster: The first step in the R function is to create a new matrix, clus.d, that contains only the rows of the matrix m where the cluster label in the clus vector is equal to the cluster of interest coi. This is done using the which() function to find the indices of the rows that belong to the target cluster. Calculating the Energy: The function then calculates the energy (Ek) of the cluster by summing the pairwise Euclidean distances between all the rows in clus.d. The dist() function in R calculates the Euclidean distance between each pair of rows, and sum() is used to add these distances together. Output: The energy of the cluster (Ek) is returned as the result. 4.3.2 How It Works in R R makes use of high-level functions like which() and dist(), which simplify the implementation but may introduce some overhead due to the creation of intermediate data structures. 4.4 The Rust Implementation The equivalent function in Rust is implemented with more explicit control over memory and data. Here‚Äôs the Rust code: /// Function to compute the Euclidean distance between rows of data fn euclidean_distance(&amp;self, i: usize, j: usize) -&gt; f32 { let v1 = &amp;self.data[i]; let v2 = &amp;self.data[j]; let mut sum: f32 = 0.0; for i in 0..v1.len() { sum += (v1[i] - v2[i]).powi(2); } sum.sqrt() } /// Calculates the cluster energy fn calc_ek(&amp;self, clus: usize) -&gt; f32 { let ids = self.cluster_rows(clus); let mut sum = 0.0; for i in 0..ids.len() { for j in i+1..ids.len() { sum += self.euclidean_distance(ids[i], ids[j]); } } sum } /// Which rows are in cluster `clus`? fn cluster_rows(&amp;self, clus: usize) -&gt; Vec&lt;usize&gt; { let mut ret = Vec::&lt;usize&gt;::with_capacity(self.clusters.len()); for i in 0..self.clusters.len() { if self.clusters[i] == clus { ret.push(i); } } ret } 4.4.1 Explanation of the Rust Code Euclidean Distance Calculation: In Rust, the euclidean_distance function calculates the Euclidean distance between two rows. It takes the indices of the rows (i and j) and computes the sum of squared differences between corresponding elements in the rows. Finally, it returns the square root of the sum to get the distance. Cluster Energy Calculation: The calc_ek function calculates the energy of a cluster by: Finding the indices of the rows that belong to the specified cluster using the cluster_rows function. For each pair of rows in the cluster, it computes the Euclidean distance and adds it to the total sum, which represents the cluster energy. Cluster Rows: The cluster_rows function simply iterates over the clusters vector and collects the indices of the rows that belong to the specified cluster (clus). It returns a Vec&lt;usize&gt; containing these indices. 4.4.2 How It Works in Rust Rust gives you more control over memory and data access. The program works with mutable references and does not create intermediate data structures unless necessary. The cluster_rows function is used to filter the rows based on the cluster, while the euclidean_distance function calculates the pairwise distance. That said, there are libraries that make Rust code look more like R, but I want to use as few libraries as possible here. 4.5 The main worker function The R code provided implements the simulated annealing algorithm in the following steps: Initial Cluster Assignment: A random assignment of K clusters to the rows of data is performed using sample(1:K, nrow(data), replace = TRUE). Energy Calculation: The function calc.Ek() calculates the energy of the cluster (the sum of distances between elements within the cluster). Annealing Process: In each iteration, a row (data point) is randomly chosen and moved to a new cluster. The energy of the system is recalculated based on the new cluster assignment. Acceptance Criteria: If the new configuration has a lower energy, it is accepted. If the energy is higher, the new configuration is accepted based on a probabilistic criterion derived from the temperature (simulating the annealing process). Cooling: The temperature is updated in each iteration by multiplying it with a cooling factor. #This is the main algorithm that performs the annealing. It takes the data,how #many K we are looking for, The number of iterations to perform, starting #temperature and the cooling factor. sa.ok &lt;- function(data,K,Iter,Temp,cool){ clusters &lt;- sample(1:K,nrow(data),replace = T) #initialise random clusters #clusters.o &lt;- clusters Es.old &lt;- calc.E.all(data,clusters) #E.old &lt;- E.tot(Es.old) for(i in 1:Iter){ # start iterating clusters.new &lt;- clusters #copy the clusters #Es.new &lt;- Es.old row.id &lt;- sample(1:nrow(data),1) #pick a gene at random from.c &lt;- clusters.new[row.id] # get the cluster it&#39;s moving from #to.c &lt;- sample((1:K)[!(1:K) %in% from.c],1) to.c &lt;- sample((1:K)[-from.c],1) # randomly choose a new cluster clusters.new[row.id] &lt;- to.c # replace the old cluster with the new Es.new &lt;- Es.old #make a copy of the energies vector # calc the energies of the two changed clusters Es.new[from.c] &lt;- calc.Ek(data,clusters.new,from.c) Es.new[to.c] &lt;- calc.Ek(data,clusters.new,to.c) E.new &lt;- E.tot(Es.new) # calculate the new average E E.old &lt;- E.tot(Es.old) # calculate the old average E if(E.new &lt; E.old){ # if new &lt; old accept the move copy the new clusters into the previous clusters &lt;- clusters.new #copy the new clusters into the previous Es.old &lt;- Es.new # make Enew to Eold }else{ if(calc.exp(E.new,E.old,Temp) &gt; runif(1)){ #evaluate the exprssion against the random number from runif(1) clusters &lt;- clusters.new #copy the new clusters into the previous Es.old &lt;- Es.new # make Enew to Eold } } {cat(&quot;\\r&quot;,E.old)} #print out the energy to the screen Temp &lt;- Temp*cool # cool the system } clusters # return the clusters } 4.5.1 Rust Implementation The Rust version of the algorithm closely follows the same logic as the R implementation but is adapted for performance and memory safety in the Rust programming language: Random Cluster Assignment: In Rust, clusters are assigned using rand::random_range() instead of the R sample() function. Energy Calculation: The energy calculation (calc_ek()) is similar to R‚Äôs calc.Ek(), but it uses a more efficient loop-based calculation of Euclidean distances. Annealing Process: The process for updating the cluster assignment and calculating energies is similar to the R version but is implemented with Rust‚Äôs ownership model and safety guarantees. Acceptance Criteria: The acceptance criterion is implemented with the same logic, but uses Rust‚Äôs f32::exp() to handle the energy calculations and probabilistic decision-making. Cooling: The temperature is updated similarly to R, using a multiplicative cooling factor. pub fn run( &amp;mut self, max_iter:usize, cool:f32 ) -&gt; usize { let mut it = 0; // calculate the inital energies - this will be modified later let mut old_energies= Vec::&lt;f32&gt;::with_capacity( self.k ); for i in 0..self.k { old_energies.push( self.calc_ek( i ) ); } let mut old_total: f32 = old_energies.iter().sum::&lt;f32&gt;() / self.k as f32; let mut rand = rand::rng(); for _ in 0..max_iter{ it += 1; // initate all varaibales let mut new_energies = old_energies.clone(); let moving_row = rand.random_range(0..self.data.len()); let move_from = self.clusters[moving_row]; let mut move_to = rand.random_range(0..self.k); while move_from == move_to{ move_to = rand.random_range(0..self.k); } // move the row from to self.clusters[moving_row] = move_to; // calculate the new energies new_energies[move_from] = self.calc_ek( move_from ); new_energies[move_to] = self.calc_ek( move_to ); let new_total:u32 = new_energies.iter().sum::&lt;f32&gt;() / self.k as f32; if new_total &lt; old_total || (-((new_total - old_total) / self.temp)).exp() &gt; rand.random_range(0.0..1.0){ // that is a good one - keep this old_energies[move_from] = new_energies[move_from]; old_energies[move_to] = new_energies[move_to]; old_total = new_total; }else { //this move was not good - drop it! self.clusters[moving_row] = move_from; } // cool the system self.temp *= cool; } it } There is not a lot of differences in the implementation - the rust code is even one line shorter as the R one. 4.6 And Funtions to Plot and Write the Data I assume that by now you understand what the write_clusters function is doing. Plotting is a lot different from R; I have just obtained that function structure from ChatGPT and fixed some errors. Just take it as is. use plotters::prelude::*; use std::error::Error; use std::io::Write; pub fn write_clusters(&amp;self, ofile: &amp;str, sep: char) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { // Open the file in write mode let mut file = File::create(ofile)?; // Write the header (optional) writeln!(file, &quot;Rowname{}Cluster&quot;, sep)?; // Iterate over the rownames and clusters, writing them to the file for (rowname, cluster) in self.rownames.iter().zip(self.clusters.iter()) { writeln!(file, &quot;{}{}{}&quot;, rowname, sep, cluster+1)?; } Ok(()) } pub fn plot(&amp;self, prefix:&amp;str )-&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let output_dir = Path::new(prefix).parent().unwrap_or_else(|| Path::new(&quot;.&quot;)); std::fs::create_dir_all(output_dir)?; for cluster_id in 0..self.k { let filename = format!(&quot;{}_cluster_{}.png&quot;, prefix, cluster_id +1 ); let root = BitMapBackend::new(&amp;filename, (800, 600)).into_drawing_area(); root.fill(&amp;WHITE)?; let mut chart = ChartBuilder::on(&amp;root) .caption(format!(&quot;Cluster {}&quot;, cluster_id+1), (&quot;sans-serif&quot;, 20)) .margin(20) .x_label_area_size(40) .y_label_area_size(40) .build_cartesian_2d(0..self.data[0].len(), 0.0f32..1.0)?; // Adjust Y range if needed chart.configure_mesh().draw()?; // Collect all rows belonging to this cluster let cluster_data: Vec&lt;&amp;Vec&lt;f32&gt;&gt; = self.data.iter() .zip(&amp;self.clusters) .filter(|&amp;(_, &amp;c)| c == cluster_id) .map(|(row, _)| row) .collect(); // Draw each row as a line plot for row in cluster_data { chart.draw_series(LineSeries::new( row.iter().enumerate().map(|(x, &amp;y)| (x, y)), &amp;BLUE, ))?; } root.present()?; println!(&quot;Saved: {}&quot;, filename); } Ok(()) } The plot function needs one more library: cargo add plotters If all has gone well we could improve on our tests! Add a second test case into the lib.rs file: #[test] fn tes_scale01(){ let mut obj = SimulatedAnnealing::new( &quot;tests/data/Spellman_Yeast_Cell_Cycle.tsv&quot;, 8, 1000.0, &#39;\\t&#39; ); obj.scale_01(); let exp5:Vec&lt;f32&gt; = vec![0.6989,0.0000,0.0968,0.3333,0.4301,1.0000,0.7419,0.7419,0.6022,0.7634,0.1720,0.4301,0.5161,0.7634,0.6989,0.6559]; let exp7:Vec&lt;f32&gt; = vec![0.0803,0.0000,0.2867,0.5849,0.9679,1.0000,0.7775,0.7156,0.5505,0.5459,0.4518,0.6193,0.8440,0.8532,0.9335,0.7752]; let mut dist: f32 = 0.0; for i in 0..exp5.len() { assert!( (obj.data[5][i] - exp5[i]).abs() &lt; 1e-4, &quot;Mismatch in gene 5 at index {}: got {}, expected {}&quot;, i, obj.data[5][i], exp5[i] ); assert!( (obj.data[7][i] - exp7[i]).abs() &lt; 1e-4, &quot;Mismatch in gene 7 at index {}: got {}, expected {}&quot;, i, obj.data[7][i], exp7[i] ); dist += (obj.data[7][i]-obj.data[5][i]).powi(2); } dist = dist.sqrt(); obj.clusters[5] = 8; obj.clusters[7] = 8; obj.k =9; assert_eq!( obj.calc_ek(8), dist, &quot;the distance in cluster 8 (genes 5 and 7)&quot; ); } make test -r ## make[1]: Verzeichnis ‚Äû/home/med-sal/git_Projects/tutorial_rust_simulated_annealing‚Äú wird betreten ## Building /home/med-sal/git_Projects/tutorial_rust_simulated_annealing/rust_stages/step3... ## Finished `release` profile [optimized] target(s) in 0.04s ## Running unittests src/lib.rs (target/release/deps/simulated_annealing-ec0f849373011f09) ## ## running 2 tests ## test tests::test_read_data ... ok ## test tests::tes_scale01 ... ok ## ## test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Running unittests src/main.rs (target/release/deps/simulated_annealing-34887cf23462f205) ## ## running 0 tests ## ## test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Running tests/test-SimulatedAnnealing.rs (target/release/deps/test_SimulatedAnnealing-fd16fac0ecee9aa3) ## ## running 1 test ## test test_simulated_annealing ... ok ## ## test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Doc-tests simulated_annealing ## ## running 0 tests ## ## test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Finished building /home/med-sal/git_Projects/tutorial_rust_simulated_annealing/rust_stages/step3. Logs are in step3_build.log ## make[1]: Verzeichnis ‚Äû/home/med-sal/git_Projects/tutorial_rust_simulated_annealing‚Äú wird verlassen This looks good, just that we can not use this library as we have not implemented the executable :-D ‚¨ÖÔ∏è PreviousNext ‚û°Ô∏è "],["rust-program-logioc-is-implemented-in-main.html", "Chapter 5 Rust Program Logioc is Implemented in ‚Äúmain.rs‚Äù 5.1 We have an Executable!! 5.2 Implement a ‚Äòprint‚Äô for our Class 5.3 Take Home Message", " Chapter 5 Rust Program Logioc is Implemented in ‚Äúmain.rs‚Äù If you compile the library as it is you will not be able to use it. We need to implement the main.rs file that codes for the binary. The R version of what we implement here is this: ycc &lt;- read.delim(&quot;../Spellman_Yeast_Cell_Cycle.tsv&quot;,row.names=1,header=T,sep=&quot;\\t&quot;) ycc &lt;- as.matrix(ycc) ycc.01 &lt;- t(apply(ycc,1,scale.01)) system.time(proc.time(clus &lt;- sa.ok(ycc.01,10,25000,20,0.995))) # plot the clusters using base R par(mfrow=c(3,4)) for(i in 1:max(clus)){ ycc.c &lt;- ycc.01[which(clus==i),] plot(ycc.c[1,],ty=&quot;l&quot;,ylim=range(ycc.c)) apply(ycc.c,1,lines) } But as we implement this functionality as executable it would be better to not hardcode the options: Command line options are normally parsed using the clap crate so we should add that to our project. This time I want a specific version: cargo add clap@3.0.14 --features derive We need to get the input table, the separating char for that table, the number of clusters to search for, the starting temperature, cool-down factor and max iterations to run through as well as the file we want to save the clusters to. In Rust you would do this like that: use clap::Parser; #[derive(Parser)] #[clap(version = &quot;1.0.0&quot;, author = &quot;Stefan L. &lt;stefan.lang@med.lu.se&gt;&quot;)] struct Opts { /// the input text table #[clap(short, long)] file: String, /// the column separator for the file #[clap(default_value= &quot;\\\\t&quot;,short, long)] sep: String, /// the number of clusters #[clap(short, long)] clusters: usize, /// the starting temperature #[clap(default_value_t= 20.0,short, long)] temp: f32, /// the cooling factor #[clap(default_value_t= 0.9995,short, long)] cool: f32, ///max number of iterations #[clap(default_value_t= 1000*1000,short, long)] max_it: usize, /// the grouping outfile #[clap(short, long)] outfile: String, } Here‚Äôs a breakdown of what it‚Äôs doing: use clap::Parser;: This imports the necessary functionality from the clap crate, which is used for parsing command-line arguments. #[derive(Parser)]: This macro automatically implements the Parser trait for the Opts struct. This allows the struct to be used for argument parsing in the CLI. #[clap(version = ‚Äú1.0.0‚Äù, author = ‚ÄúStefan L. stefan.lang@med.lu.se‚Äù)]: This defines metadata for the program such as its version and author, which will be shown when the user runs the command with a ‚Äìversion or ‚Äìhelp flag. struct Opts { ‚Ä¶ }: The Opts struct holds the various command-line arguments that the program will accept. Each three lines corresponds to a command-line argument with hep srting, options and variable definition. The different clap options we are using here mean short use the variable names first character for a short option like -f for file long use the variable name as long option line ‚Äìfile for file default_value the default String value if the user does not specify one default_value_t used for default values that are not a String The main function is quite simple ‚Äî half of it is just calculating the time taken for the program to execute. Give it a try! use std::time::SystemTime; // this is specific for my package which I have called simulated_annealing_new as I had an other version, too. use simulated_annealing::SimulatedAnnealing; fn main() { let now = SystemTime::now(); let opts: Opts = Opts::parse(); let mut sep = &#39;\\t&#39;; if &amp;opts.sep != &quot;\\\\t&quot;{ //println!(&quot;I set sep to {}&quot;, opts.sep ); sep = opts.sep.chars().next().unwrap(); } let mut sim = SimulatedAnnealing::new( &amp;opts.file, opts.clusters, opts.temp, sep ); sim.scale_01(); //println!(&quot;Initial state: {sim}&quot;); let iterations = sim.run( opts.max_it, opts.cool ); let _= sim.plot( &amp;opts.outfile ); //println!(&quot;Final state {sim} in {iterations} iterations&quot;); match sim.write_clusters( &amp;opts.outfile, sep ){ Ok(_) =&gt; println!(&quot;Clusters written to {}&quot;, &amp;opts.outfile ), Err(e) =&gt; eprintln!(&quot;Failed to write the data to {}: {:?}&quot;, &amp;opts.outfile, e), } match now.elapsed() { Ok(elapsed) =&gt; { let mut milli = elapsed.as_millis(); let mil = milli % 1000; milli= (milli - mil) /1000; let sec = milli % 60; milli= (milli -sec) /60; let min = milli % 60; milli= (milli -min) /60; eprintln!(&quot;finished in {milli} h {min} min {sec} sec {mil} milli sec&quot;); }, Err(e) =&gt; {println!(&quot;Error: {e:?}&quot;);} } } Now compile and test it: cargo test -r ## make[1]: Verzeichnis ‚Äû/home/med-sal/git_Projects/tutorial_rust_simulated_annealing‚Äú wird betreten ## Building /home/med-sal/git_Projects/tutorial_rust_simulated_annealing/rust_stages/step4... ## warning: unused variable: `iterations` ## --&gt; src/main.rs:48:9 ## | ## 48 | let iterations = sim.run( opts.max_it, opts.cool ); ## | ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_iterations` ## | ## = note: `#[warn(unused_variables)]` on by default ## ## warning: `simulated_annealing` (bin &quot;simulated_annealing&quot;) generated 1 warning ## warning: `simulated_annealing` (bin &quot;simulated_annealing&quot; test) generated 1 warning (1 duplicate) ## Finished `release` profile [optimized] target(s) in 0.04s ## Running unittests src/lib.rs (target/release/deps/simulated_annealing-ec0f849373011f09) ## ## running 2 tests ## test tests::tes_scale01 ... ok ## test tests::test_read_data ... ok ## ## test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Running unittests src/main.rs (target/release/deps/simulated_annealing-34887cf23462f205) ## ## running 0 tests ## ## test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Running tests/test-SimulatedAnnealing.rs (target/release/deps/test_SimulatedAnnealing-fd16fac0ecee9aa3) ## ## running 1 test ## test test_simulated_annealing ... ok ## ## test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Doc-tests simulated_annealing ## ## running 0 tests ## ## test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s ## ## Finished building /home/med-sal/git_Projects/tutorial_rust_simulated_annealing/rust_stages/step4. Logs are in step4_build.log ## make[1]: Verzeichnis ‚Äû/home/med-sal/git_Projects/tutorial_rust_simulated_annealing‚Äú wird verlassen 5.1 We have an Executable!! You now can run the executable target/release/simulated_annealing like that: target/release/simulated_annealing -f tests/data/Spellman_Yeast_Cell_Cycle.tsv --clusters 8 --temp 20 --outfile /tmp/clusters.tsv ## Saved: /tmp/clusters.tsv_cluster_1.png ## Saved: /tmp/clusters.tsv_cluster_2.png ## Saved: /tmp/clusters.tsv_cluster_3.png ## Saved: /tmp/clusters.tsv_cluster_4.png ## Saved: /tmp/clusters.tsv_cluster_5.png ## Saved: /tmp/clusters.tsv_cluster_6.png ## Saved: /tmp/clusters.tsv_cluster_7.png ## Saved: /tmp/clusters.tsv_cluster_8.png ## Saved: /tmp/clusters.tsv_cluster_9.png ## Saved: /tmp/clusters.tsv_cluster_10.png ## Clusters written to /tmp/clusters.tsv ## finished in 0 h 0 min 0 sec 191 milli sec 5.2 Implement a ‚Äòprint‚Äô for our Class The output from our simulation is missing key information ‚Äî we want to display the system‚Äôs energy before and after processing. In an R S3 class, we would implement a custom print method like this: SCRIPTr print.simulatedAnnealing &lt;- function(x) { # Format and display info about x } SCRIPT This allows you to simply call print(x) and get a meaningful summary of the object. Rust doesn‚Äôt have classical inheritance like R‚Äôs S3/S4 or R6 systems. Instead, Rust uses traits, which act like interfaces or capabilities. A type can implement a trait to gain specific behavior ‚Äî similar to adding methods in R. To define a custom print format in Rust, we implement the Display trait: SCRIPTrust use std::fmt; impl fmt::Display for SimulatedAnnealing { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;‚Äô_&gt;) -&gt; fmt::Result { let mut sum = 0.0_f32; for i in 0..self.k { sum += self.calc_ek(i); } sum /= self.k as f32; write!( f, ‚ÄúSimulatedAnnealing (temperature: {:.2}, total energy: {:.2} for {} clusters)‚Äù, self.temp, sum, self.k ) } } SCRIPT This gives the struct a user-friendly string representation, just like implementing print() for a class in R. Afterwards we can change our main.rs and add the print statements: fn main() { let now = SystemTime::now(); let opts: Opts = Opts::parse(); let mut sep = &#39;\\t&#39;; if &amp;opts.sep != &quot;\\\\t&quot;{ //println!(&quot;I set sep to {}&quot;, opts.sep ); sep = opts.sep.chars().next().unwrap(); } let mut sim = SimulatedAnnealing::new( &amp;opts.file, opts.clusters, opts.temp, sep ); sim.scale_01(); println!(&quot;Initial state: {sim}&quot;); let iterations = sim.run( opts.max_it, opts.cool ); let _= sim.plot( &amp;opts.outfile ); println!(&quot;Final state {sim} after {iterations} iterations&quot;); match sim.write_clusters( &amp;opts.outfile, sep ){ Ok(_) =&gt; println!(&quot;Clusters written to {}&quot;, &amp;opts.outfile ), Err(e) =&gt; eprintln!(&quot;Failed to write the data to {}: {:?}&quot;, &amp;opts.outfile, e), } match now.elapsed() { Ok(elapsed) =&gt; { let mut milli = elapsed.as_millis(); let mil = milli % 1000; milli= (milli - mil) /1000; let sec = milli % 60; milli= (milli -sec) /60; let min = milli % 60; milli= (milli -min) /60; eprintln!(&quot;finished in {milli} h {min} min {sec} sec {mil} milli sec&quot;); }, Err(e) =&gt; {println!(&quot;Error: {e:?}&quot;);} } } I have not modified my examples here - so this is something you can do all for yourself. If we have more time we could implement one more improvement to the library: Add a store variable into the class and populate it with the row to row distances after you have scaled the data. Then modify the calc_ek() function to use the values from the store and not calculate the distances every single time. This should give you an additional x5 speed improvement if you store it as a Vec&lt;Vec&gt; again. If you use a single vector and an index function you could get an even better performance. 5.3 Take Home Message The implementation of the functions is significantly different from R or Python, but with the compiler and the AI assistance we can get at the moment it, is doable. Coding in Rust takes time to get into, but the speed improvements can be worth it. This example here does not really highlight the usability as the R code also finished in a reasonable amount of time, but if you have more complicated tasks - like processing BAM files or anything else that is (1) either easy to implement in a multiprocessor system or (2) needs to process binary data, it is worth to look into Rust. It is somewhat slower than C and C++ (like 3 to 5 times?), but Rust is so much easier to program in if you come from R and Python - it is worth it. By the way - I used a ArrayBase&lt;ndarray::OwnedRepr, Dim&lt;[usize; 2]&gt;&gt; for my store and gained another speed boost of factor 2. Given the fact that this takes either 60 or 30 milliseconds this is no big deal. For the sake of this tutorial I think a Vec&lt;Vec&lt;_&gt;&gt; is easier to work with. You can check out my other implementation here. ‚¨ÖÔ∏è Previous "],["error-handling.html", "Chapter 6 Error Handling in Rust 6.1 1. Unrecoverable Errors (panic!) 6.2 2. Recoverable Errors (Result&lt;T, E&gt;) 6.3 3. Custom Errors with thiserror and anyhow 6.4 Summary of Rust Error Handling Techniques", " Chapter 6 Error Handling in Rust Rust provides a powerful error-handling system that helps ensure robustness and reliability. There are two main types of errors: 6.1 1. Unrecoverable Errors (panic!) Unrecoverable errors occur when the program reaches an unexpected state and must terminate immediately. Rust handles these with panic!(). 6.1.1 Example: fn main() { panic!(&quot;Something went wrong!&quot;); } 6.1.2 When to Use panic!() Critical failure where recovery is impossible. Development &amp; debugging to catch issues early. Assertions in tests using assert!() or assert_eq!(). 6.1.3 Handling Panics Gracefully Instead of crashing the whole program, you can use std::panic::catch_unwind() to handle a panic in certain cases: use std::panic; fn main() { let result = panic::catch_unwind(|| { panic!(&quot;This will be caught&quot;); }); if result.is_err() { println!(&quot;A panic occurred, but the program is still running.&quot;); } } 6.2 2. Recoverable Errors (Result&lt;T, E&gt;) Recoverable errors occur when an operation might fail but doesn‚Äôt necessarily require termination. Rust uses the Result&lt;T, E&gt; type for these cases. 6.2.1 Example: use std::fs::File; use std::io::Error; fn main() -&gt; Result&lt;(), Error&gt; { let file = File::open(&quot;config.txt&quot;)?; // If error, return it Ok(()) } 6.2.2 Result&lt;T, E&gt; Explanation Ok(T): The operation was successful and returns T. Err(E): The operation failed and returns an error E. 6.2.3 Common Ways to Handle Result&lt;T, E&gt; 6.2.3.1 1. Propagate the Error (? Operator) fn read_file() -&gt; Result&lt;String, std::io::Error&gt; { let content = std::fs::read_to_string(&quot;config.txt&quot;)?; Ok(content) } The ? operator short-circuits on Err(E), returning it immediately. Only works in functions that return Result&lt;T, E&gt;. 6.2.3.2 2. Handle the Error Manually use std::fs::File; fn main() { let file = File::open(&quot;config.txt&quot;); match file { Ok(f) =&gt; println!(&quot;File opened successfully!&quot;), Err(e) =&gt; println!(&quot;Failed to open file: {}&quot;, e), } } The match statement allows custom error handling. 6.2.3.3 3. Use unwrap() or expect() (Risky!) let file = File::open(&quot;config.txt&quot;).unwrap(); // Panics if it fails let file = File::open(&quot;config.txt&quot;).expect(&quot;Failed to open file&quot;); // Custom panic message Use only if you are sure the operation will succeed. Recommended for quick prototyping or tests. 6.2.3.4 4. Using unwrap_or() and unwrap_or_else() use std::fs::File; fn main() { let file = File::open(&quot;config.txt&quot;).unwrap_or_else(|_| { println!(&quot;File not found, creating a new one.&quot;); File::create(&quot;config.txt&quot;).expect(&quot;Failed to create file&quot;) }); } unwrap_or(default_value) provides a fallback value. unwrap_or_else(|err| handle_error(err)) allows custom error handling. 6.3 3. Custom Errors with thiserror and anyhow For complex applications, defining custom error types is beneficial. 6.3.1 Using thiserror for Custom Errors use thiserror::Error; #[derive(Debug, Error)] pub enum MyError { #[error(&quot;File error: {0}&quot;)] FileError(std::io::Error), #[error(&quot;Invalid input: {0}&quot;)] InvalidInput(String), } Use #[error(\"message\")] to format error messages. Allows structured error handling. 6.3.2 Using anyhow for Simpler Error Handling use anyhow::{Context, Result}; use std::fs::File; fn open_file() -&gt; Result&lt;File&gt; { let file = File::open(&quot;config.txt&quot;).context(&quot;Could not open config file&quot;)?; Ok(file) } anyhow::Result&lt;T&gt; allows returning multiple error types easily. .context() provides custom error messages. 6.4 Summary of Rust Error Handling Techniques Technique Use Case panic!() Unrecoverable errors that should crash the program. Result&lt;T, E&gt; Recoverable errors where failure is an expected possibility. ? operator Propagating errors in functions returning Result&lt;T, E&gt;. match Custom error handling logic. unwrap() / expect() Quick debugging, but avoid in production. unwrap_or() / unwrap_or_else() Provide default values or custom error handling. thiserror Custom structured error types. anyhow Simple error handling with better error messages. By following these practices, you can write safe, reliable, and robust Rust applications! üöÄ "],["testing.html", "Chapter 7 Testing in Rust 7.1 1. Writing Basic Unit Tests 7.2 2. Running Tests 7.3 3. Testing for Panics 7.4 4. Using Result&lt;T, E&gt; in Tests 7.5 5. Ignoring Tests 7.6 6. Benchmarking with #[bench] 7.7 7. Integration Tests 7.8 8. Testing the Executable 7.9 Summary", " Chapter 7 Testing in Rust Rust has a built-in testing framework that enables developers to write and run tests efficiently. Tests help ensure code correctness, prevent regressions, and improve maintainability. 7.1 1. Writing Basic Unit Tests Rust tests are written inside a module annotated with #[cfg(test)] and individual tests use #[test]. 7.1.1 Example: #[cfg(test)] mod tests { use super::*; #[test] fn test_addition() { assert_eq!(2 + 2, 4); } } #[cfg(test)] ensures the module is only compiled when running tests. #[test] marks a function as a test. assert_eq!(a, b) checks if a == b, failing the test otherwise. 7.1.2 Common Assertions: Macro Description assert!(condition) Fails if condition is false. assert_eq!(a, b) Fails if a != b, shows values. assert_ne!(a, b) Fails if a == b, shows values. 7.2 2. Running Tests To execute all tests, run: cargo test Runs all test functions inside #[cfg(test)] modules. Captures standard output unless --nocapture is used: cargo test -- --nocapture Runs specific tests using: cargo test test_addition 7.3 3. Testing for Panics Use #[should_panic] to test for expected panics. #[test] #[should_panic(expected = &quot;divide by zero&quot;)] fn test_divide_by_zero() { let _ = 1 / 0; } The test passes if it panics with the expected message. 7.4 4. Using Result&lt;T, E&gt; in Tests Instead of panicking, tests can return Result&lt;(), E&gt; for better error handling. #[test] fn test_file_reading() -&gt; Result&lt;(), std::io::Error&gt; { let content = std::fs::read_to_string(&quot;test_file.txt&quot;)?; assert!(content.contains(&quot;Hello&quot;)); Ok(()) } Recommended for tests involving I/O or other fallible operations. 7.5 5. Ignoring Tests Some tests may take a long time. Use #[ignore] to exclude them from default runs: #[test] #[ignore] fn long_running_test() { std::thread::sleep(std::time::Duration::from_secs(10)); } Run ignored tests with: cargo test -- --ignored 7.6 6. Benchmarking with #[bench] Rust provides benchmarking via the test crate (nightly only): #![feature(test)] extern crate test; use test::Bencher; #[bench] fn bench_addition(b: &amp;mut Bencher) { b.iter(|| 2 + 2); } Run benchmarks with: cargo bench 7.7 7. Integration Tests Integration tests are placed in the tests/ directory and test the external interface of the library. 7.7.1 Example tests/integration_test.rs: use my_crate::add; #[test] fn test_add() { assert_eq!(add(2, 3), 5); } Uses use my_crate::*; to import public API functions. Each file in tests/ is compiled separately. 7.8 8. Testing the Executable For projects that generate a binary, you can test the executable by running it as a subprocess and checking its output. 7.8.1 Example tests/test_binary.rs: use std::process::Command; #[test] fn test_executable_output() { let output = Command::new(&quot;target/debug/my_binary&quot;) .arg(&quot;--version&quot;) .output() .expect(&quot;Failed to execute binary&quot;); let stdout = String::from_utf8_lossy(&amp;output.stdout); assert!(stdout.contains(&quot;my_binary 1.0.0&quot;)); } Uses std::process::Command to execute the compiled binary. Checks if the output matches the expected version string. 7.9 Summary Feature Description #[test] Defines a unit test. assert!, assert_eq!, assert_ne! Assertion macros. cargo test Runs all tests. #[should_panic] Tests expected panics. Result&lt;(), E&gt; Allows fallible tests. #[ignore] Skips tests unless explicitly run. cargo bench Runs performance benchmarks (nightly only). Integration Tests Stored in tests/, test public APIs. Executable Testing Uses std::process::Command to verify binary output. By following these testing best practices, you can ensure your Rust code is robust, maintainable, and reliable! üöÄ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
